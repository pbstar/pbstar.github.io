/*!
* fitview v0.3.3
* Copyright 2024 Pbstar (https://github.com/pbstar)
* Licensed under MIT (https://github.com/pbstar/fitview/blob/main/LICENSE)
* 2025-06-11 10:49:55
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).fitview=t()}(this,(function(){"use strict";function e(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)}var t;"function"==typeof SuppressedError&&SuppressedError;return t=new WeakMap,class{constructor(s){if(t.set(this,{el:null,fit:"contain",resize:!0,vw:0,vh:0,dw:1920,dh:1080,resizeObserver:null}),!s)return void console.warn("config is required");if(!(s.el&&s.el instanceof HTMLElement))return void console.warn("el is required");if(1!=s.el.children.length)return void console.warn("el must have only one child element");const i=["fill","contain","scroll","hidden"];if(e(this,t,"f").el=s.el,e(this,t,"f").resize=s.resize||!0,s.fit){if(!i.includes(s.fit))return void console.warn("fit must be one of fill, contain, scroll, hidden");e(this,t,"f").fit=s.fit}const r=()=>{const s=function(e){const t={vw:0,vh:0,dw:1920,dh:1080},s=e.children[0];return s?e.offsetWidth>0&&e.offsetHeight>0&&s.offsetWidth>0&&s.offsetHeight>0?{vw:e.offsetWidth,vh:e.offsetHeight,dw:s.offsetWidth,dh:s.offsetHeight}:(console.warn("el and its child element must have width and height"),t):(console.warn("el must have only one child element"),t)}(e(this,t,"f").el);e(this,t,"f").vw=s.vw,e(this,t,"f").vh=s.vh,e(this,t,"f").dw=s.dw,e(this,t,"f").dh=s.dh,function(e){const t=Math.round(e.vw/e.dw*1e3)/1e3,s=Math.round(e.vh/e.dh*1e3)/1e3,i=e.el,r=e.el.children[0];if(r.style.transformOrigin="0 0",i.style.overflow="hidden",i.style.scrollbarColor="rgba(255, 255, 255, 0.3) rgba(255, 255, 255, 0.1)","fill"==e.fit)r.style.transform=`scale( ${t}, ${s} )`;else if("contain"==e.fit)if(t>s){r.style.transform=`scale( ${s}, ${s} )`;const t=Math.round((e.vw-e.dw*s)/2);r.style.marginLeft=`${t}px`}else r.style.transform=`scale( ${t}, ${t} )`,r.style.marginLeft="0";else if("scroll"==e.fit)t>s?(r.style.transform=`scale( ${t}, ${t} )`,i.style.overflowX="hidden",i.style.overflowY="scroll",r.style.marginRight="0",r.style.marginBottom=`${Math.round(e.vh-e.dh)}px`):(r.style.transform=`scale( ${s}, ${s} )`,i.style.overflowX="scroll",i.style.overflowY="hidden",r.style.marginRight=`${Math.round(e.vw-e.dw)}px`,r.style.marginBottom="0");else if("hidden"==e.fit)if(t>s)r.style.transform=`scale( ${t}, ${t} )`,r.style.marginLeft="0";else{r.style.transform=`scale( ${s}, ${s} )`;const t=Math.round((e.dw*s-e.vw)/2);r.style.marginLeft=`-${t}px`}}(e(this,t,"f"))};e(this,t,"f").resize?(e(this,t,"f").resizeObserver=new ResizeObserver((()=>{r()})),e(this,t,"f").resizeObserver.observe(e(this,t,"f").el)):r(),this.api={refresh:r,destroyResize:()=>{e(this,t,"f").resizeObserver&&(e(this,t,"f").resizeObserver.disconnect(),e(this,t,"f").resizeObserver=null)}}}}}));
